#pragma config(Motor,  port1,           M1,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           M2,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          M3,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

char cha1[375];      //////////////////////////
char cha2[375];      // These are our arrays //
char cha3[375];      // for analog channels. //
char cha4[375];      //////////////////////////

short cha5678[375];  // <-- This array is for all 12 digital buttons

bool recing = false; // Poorly named variable telling us if the robot is recording or playing it back.

#define clrBtns 0b000000000000  ////////////////////////////////////////////////////////////////
#define b5U     0b100000000000  //                                                            //
#define b5D     0b010000000000  //  Binary! The data that gets stored in the cha5678[] array  //
#define b6U     0b001000000000  //  is saved like this. Each button is assigned a value as    //
#define b6D     0b000100000000  //  seen here. Button 8D, for example, will return a value of //
#define b7U     0b000010000000  //  1 when it's pressed. 8U will return 2 when pressed. This  //
#define b7L     0b000001000000  //  is easier to visualize in binary if you imagine each bit  //
#define b7R     0b000000100000  //  is showing you the value of a predetermined button. We    //
#define b7D     0b000000010000  //  will see later how the robot uses these values to store   //
#define b8U     0b000000001000  //  or read a complex number and associate it with a certain  //
#define b8L     0b000000000100  //  button.                                                   //
#define b8R     0b000000000010  //                                                            //
#define b8D     0b000000000001  //////////////////////////////////////////////////////////////// 

byte joyBtnsTemp = clrBtns;  // This variable uses bitshift OR to compile all the buttons pressed and store them.

task recording()  // This is where we record our auton!
{
	int t=0;      // Set t to 0, this is our timer.
	while(t<375)  // This loop (should) be about 40ms. 375*40ms = 15000ms, AKA one auton period.
	{
		motor[M1] = vexRT[Ch2];                              //  You want the robot to actually
		motor[M2] = vexRT[Ch3];                              //  move while you're recording,
		motor[M3] = vexRT[Btn5U]*127 + vexRT[Btn5D]*(-127);  //  right?
        
		cha1[t] = vexRT[Ch1];  //////////////////////////////////////////////////////////////////
		cha2[t] = vexRT[Ch2];  //  Store the current analog value (-127 to 127) to the analog  //
		cha3[t] = vexRT[Ch3];  //  arrays, in position t (t increases by 1 every 40 ms).       //
		cha4[t] = vexRT[Ch4];  //////////////////////////////////////////////////////////////////
        
		joyBtnsTemp = clrBtns;  //  Clear the "compiler variable" (is that a good name?)
        
		if (vexRT[Btn5U] == 1)                ///////////////////////////////////////
		{                                     //
			joyBtnsTemp = joyBtnsTemp | b5U;  //  Ok!
		}                                     //  So this is the bulk of the code.
		if (vexRT[Btn5D] == 1)                //  Here we can see the binary values
		{                                     //  we associated with buttons being
			joyBtnsTemp = joyBtnsTemp | b5D;  //  used. Basically, every button
		}                                     //  pressed triggers an if statement
		if (vexRT[Btn6U] == 1)                //  that adds that value to the temp
		{                                     //  storage variable, and after all
			joyBtnsTemp = joyBtnsTemp | b6U;  //  buttons have been checked it dumps
		}                                     //  the sum of it all in the cha5678
		if (vexRT[Btn6D] == 1)                //  array. For example: If you're
		{                                     //  pressing button 5U, when the robot
			joyBtnsTemp = joyBtnsTemp | b6D;  //  checks the buttons, it ORs ( | )
		}                                     //  the joyBtnsTemp variable with the
		if (vexRT[Btn7U] == 1)                //  definition of b5U. OR simply means
		{                                     //  that if either binary string has a
			joyBtnsTemp = joyBtnsTemp | b7U;  //  1 in a certain slot, then the
		}                                     //  result will have a 1 in that slot.
		if (vexRT[Btn7L] == 1)                //
		{                                     //  0b000000000000 <- Cleared variable
			joyBtnsTemp = joyBtnsTemp | b7L;  //  ORed by
		}                                     //  0b100000000000 <- Value of b5U
		if (vexRT[Btn7R] == 1)                //  Returns
		{                                     //  0b100000000000 <- New variable
			joyBtnsTemp = joyBtnsTemp | b7R;  //
		}                                     //  As new buttons are checked, the
		if (vexRT[Btn7D] == 1)                //  first bit in this will stay 1.
		{                                     //  
			joyBtnsTemp = joyBtnsTemp | b7D;  //  0b100000000000 <- Old variable 
		}                                     //  ORed by
		if (vexRT[Btn8U] == 1)                //  0b000000001000 <- Value of b8U
		{                                     //  Returns
			joyBtnsTemp = joyBtnsTemp | b8U;  //  0b100000001000 <- New variable
		}                                     //
		if (vexRT[Btn8L] == 1)                //  "Isn't this redundant?"
		{                                     //
			joyBtnsTemp = joyBtnsTemp | b8L;  //  Yes, it totally is. Because we're
		}                                     //  always starting with 0, we may as
		if (vexRT[Btn8R] == 1)                //  well just add them instead of ORing
		{                                     //  them. But I've been going for a bit
			joyBtnsTemp = joyBtnsTemp | b8R;  //  of a binary theme here for
		}                                     //  simplicity and I'm pretty sure it's
		if (vexRT[Btn8D] == 1)                //  easier on the microcontroller to OR
		{                                     //  instead of using addition.
			joyBtnsTemp = joyBtnsTemp | b8D;  //
		}                                     ///////////////////////////////////////
		cha5678[t] = joyBtnsTemp;  // -Aforementioned setting cha5678 into its new value.
		wait1Msec(40);             // -I'd like to increase the array size in the future
		t++;                       //  so that it isn't so "choppy".
	}
	recing = false;  // After this loop finishes, signal that it has stopped recording!
}

task playBack()   // This is where the robot performs our auton!
{
	int t = 0;    // Set t to 0, this is still our timer.
	while(t<375)  // I've explained this already.
	{
	  motor[M1] = cha2[t];             ///////////////////////////////////////////////////////////////
	  motor[M2] = cha3[t];             //  So this is basically just a usercontrol function, but    //
	  if (cha5678[t]&b5U == b5U)       //  instead of checking joystick values, you check array     //
      {                                //  values. For analog it's as simple as you'd expect:       //
	  	motor[M3] = 127;               //  The value stored is a number -127 to 127.                //
	  }                                //  For digital buttons, however, the value stored could     //
	  else if (cha5678[t]&b5D == b5D)  //  be any number from 0 to 2047. To check to see if a       //
	  {                                //  specific button was pressed, we AND the value with a     //
	  	motor[M3] = -127;              //  defined button value. If both slots have 1, then the     //
	  }                                //  byte is passed on to the result.                         //
		wait1Msec(40);                 //  0b101100101000 (Value) AND 0b100000000000 (b5U) becomes  //
		t++;                           //  0b100000000000. Since the result is equal to b5u,        //
	}                                  //  Value & b5U == b5U. Value & b8D  would be 0, != b8D.     //
	recing = false;  // Completion flag. ///////////////////////////////////////////////////////////
}

task main()
{
	while (true)
	{
		motor[M1] = vexRT[Ch2];                              //
		motor[M2] = vexRT[Ch3];                              // Do what you want here, it's usercontrol!
		motor[M3] = vexRT[Btn5U]*127 + vexRT[Btn5D]*(-127);  //
		if (vexRT[Btn8U]==1)                                 // I decided to make button 8U start the
		{                                                    // recording task when it's pressed and
			while (vexRT[Btn8U]==1)                          // released. Then, it sets bool recing to
			{                                                // true and the main task freezes while it's
			}                                                // true. If you press 8D, it does the same
			recing = true;                                   // thing, but runs the playBack task instead.
			startTask(recording);                            // 
			while (recing == true)                           // stopTask probably isn't necessary, it's
			{                                                // just a precaution.
			}                                                //
			stopTask(recording);                             //
			recing = false;                                  //
		}                                                    //
		if (vexRT[Btn8D]==1)                                 //
		{                                                    // And that's it!
			while (vexRT[Btn8D]==1)                          // Temporary recordable Auton V1 does not
			{                                                // use sensors yet (aww).
			}                                                // 
			recing = true;                                   // Variables are cleared upon bot reset, this
			startTask(playBack);                             // is clearly the inferior version.
			while (recing == true)                           //
			{                                                // -"Where are you hiding the good codes!"
			}                                                //
			stopTask(recording);                             //            >///<                    （。-＿- 。）
			recing = false;                                  // -"I'm still working on those... Give me more time!"
		}                                                    // 
	}                                                        //
}